# <a name="main"></a>	ADAPI

---

Библиотека для быстрого создания универсального RESTful API без написания кода на основе моделей. Построена на платформе [Django REST framework](https://www.django-rest-framework.org/).

Универсальный API предоставляет возможности:

* Стандартные операции CRUD (CREATE, READ, UPDATE, DELETE).
* Пагинация вида [PageNumberPagination](https://www.django-rest-framework.org/api-guide/pagination/#pagenumberpagination).
* Любые условия фильтрации и сортировки (в зависимости от типа) по любым полям модели и связных моделей (первого уровня).
* Поиск по любым текстовым полям.
* Выбор какие поля будут содержаться в ответе.
* Вложенные объекты в ответе либо вынесенные в отдельную секцию.
* Добавление ответа табличными частями(при их наличии) как полей модели при операции Retrieve.
* Дополненные возможности операций CREATE, UPDATE для сохранения табличных частей(при их наличии) вместе с сохраняемым объектом.
* Быстрое создание Action из метода модели.
* Автоматической маршрутизации URL-адресов для всех зарегистрированных моделей на платформе [wq.db](https://wq.io/wq.db/router).
* Группировка результатов с расчетом агрегатных функций (MIN, MAX, AVG, COUNT, SUM).
* Расширенный OPTIONS по полям связных моделей (имя модели, URL, поля).

---

Более подробно с возможностями ADAPI можно ознакомиться в документации по ссылке ``ссылка``

---

# <a name="usage"></a>	Использование

---

Для того чтобы использовать ``adapi`` достаточно произвести установку пакета, и необходимых [настроек](#settings),
после чего необходимо подключить модели для которых хотим создать универсальный API:

``../urls.py``

    from ... import ModelName, ...
    from adapi.router import base_router
    
    base_router.register_model(ModelName)
    ...
    Все. RESTful API со всеми возможностями описанными [выше](#main) готов!

---

# <a name="requirements"></a>	Требования

---

1. Python (3.9)
2. Django (3.1)
3. Django REST framework (3.12)
4. wq (1.2)

---

# <a name="install"></a>	Установка

---

Установка с использованием ``pip``(рекомендуется)...

    $ pip install git+https://git.digitatl.ru/nazarov-na/adapi.git
    Или из источника...
    
    $ git clone https://git.digitatl.ru/nazarov-na/adapi.git
    $ cd adapi
    $ pip install -e .
---

# <a name="settings"></a>	Настройки

---

Необходимые настройки ``settings.INSTALLED_APPS``.

    INSTALLED_APPS = [
    ...
    'rest_framework',
    'django_filters',
    'wq.db.rest',
    'adapi',
    ...
        ]
# <a name="example"></a>	Примеры

### Пагинация

Размер страницы можно варьировать параметром ``page_size`` запроса. Номер страницы указывается в параметре ``page``.

    /example/?page_size=100&page=3
### Сортировка

Сортировку можно установить с помощью параметра (``ordering``).

    /example/?ordering=id
### Фильтрация

Фильтры можно установить указав поле поиска (при необходимости указать тип поиска) и значение.

    /example/?name=Организация
    /example/?id__in=1,2,3,4

### Поиск

Поиск по текстовым полям можно установить с помощью параметра (``search``).

    /example/?search=организац

### Вложенные объекты

Получение ответа с вложенными полями вынесенными в отдельную секцию можно получить задав параметр ``include``.
Вложенные объекты можно получить из секции ``include`` по ключам соответствующим наименованиям объектов(параметр ``related_model_name`` в OPTIONS запросе).

Для случая, когда необходимо вынести в отдельную секцию все объекты ссылочного типа, необходимо в параметре запроса ``include`` установить значение ``all``.
Но, если Вам нужно вынести в секцию ``include`` только одно/несколько вложенных полей, то в параметре ``include`` необходимо перечислить эти поля.
Например, Вам нужен список статей(articles) и список комментариев к каждой статье:

          /articles?include=comments — запрашиваем статью с комментариями

          "results":
          {
          "data":
              [
                  {
                  "id": 1
                  "title": "Статья 1"
                  "author": "Автор 1"
                  "comments": "1"
                  },
                  {
                  "id": 2
                  "title": "Статья 1"
                  "author": "Автор 1"
                  "comments": "2"
                  },
                  {
                  "id": 3
                  "title": "Статья 2"
                  "author": "Автор 2"
                  "comments": "3"
                  }
              ]
          "include":
              {
              "Comments": 
                  [
                      {
                      "id":1
                      "title": Комментарий 1
                      },
                      {
                      "id":2
                      "title": Комментарий 2
                      },
                      {
                      "id":3
                      "title": Комментарий 3
                      }
                  ]
              }
          }
### Добавление ответа табличными частями при операции Retrieve

При операции Retrieve поля объекта дополняются его табличными частями.
Например, Вы делаете запрос к документу ПриходТовара, имеющего табличную часть СписокТоваров

    GET /product_arrival/1
    {
    "data": {
        "id": 1,
        "number": 00001,
        "posted": false,
        "deletion_mark": true,
        "date": "2021-11-30T09:00:00Z",
        "list_of_products": [
            {
                "id": 1,
                "line_number": 1,
                "owner": 1,
                "name": "Утюг"
            },
            {
                "id": 2,
                "line_number": 2,
                "owner": 1,
                "name": "Сковородка"
            }
        ],
    
            }
    }
### Дополненные возможности операций CREATE, UPDATE для сохранения табличных частей вместе с сохраняемым объектом

Для сохранения объектов вместе с табличными частями необходимо в теле запроса передать табличные части как поля объекта.
При этом, отсутствующие в теле запроса записи табличных частей будут удалены.
Например, Вы создаете новый документ ПриходТовара, имеющий табличную часть СписокТоваров

    POST /product_arrival
    
    ТелоЗапроса
    {
        "date": "2021-11-30T09:00:00Z",
        "list_of_products": [
            {
                "line_number": 1,
                "owner": 1,
                "name": "Утюг"
            },
            {
                "line_number": 2,
                "owner": 1,
                "name": "Сковородка"
            }
        ],
    
    }
    
    Ответ
        {
        "id": 1
        "number": 00001,
        "posted": false,
        "deletion_mark": true,
        "date": "2021-11-30T09:00:00Z",
        "list_of_products": [
            {
                "id": 1,
                "line_number": 1,
                "owner": 1,
                "name": "Утюг"
            },
            {
                "id": 2,
                "line_number": 2,
                "owner": 1,
                "name": "Сковородка"
            }
        ],
    
    }

Или например, Вы обновляете существующий документ ПриходТовара, имеющий табличную часть СписокТоваров

    PATCH или PUT /product_arrival/1
    
        ТелоЗапроса
    {
        "id": 1
        "number": 00001,
        "posted": false,
        "deletion_mark": true,
        "date": "2021-11-30T09:00:00Z",
        "list_of_products": [
            {
                "id": 1,
                "line_number": 1,
                "owner": 1,
                "name": "Утюг"
            },
            {
                "line_number": 2,
                "owner": 1,
                "name": "Сковородка"
            }
        ],
    
    }
    
    Ответ
        {
        "id": 1
        "number": 00001,
        "posted": false,
        "deletion_mark": true,
        "date": "2021-11-30T09:00:00Z",
        "list_of_products": [
            {
                "id": 1,
                "line_number": 1,
                "owner": 1,
                "name": "Утюг"
            },
            {
                "id": 2,
                "line_number": 2,
                "owner": 1,
                "name": "Сковородка"
            }
        ],
    
    }
### Выбор полей в ответе

Выбрать какие поля будут содержаться в ответе можно с помощью параметра параметр ``fields``
Например, Вам нужен список пользователей, но вас интересуют только поля "id" и "username":

    GET /users/?fields=id,username
    
      [ 
        { 
        "id": 1, 
        "username": "user1" 
        }, 
        { 
        "id": 2, 
        "username": "user2" 
        } 
      ]
### Группировка результатов с расчетом агрегатных функций

Для расчета агрегатных функций (суммы, среднего, подсчета количества, поиск максимума/минимума) по полям с группировкой
необходимо указать в параметре ``fields`` тип агрегатной функции.
Например, Вам нужен список наименований товаров, с суммой по полю ``number_of_sales`` для каждого товара:

    GET /product/?fields=name,number_of_sales__sum
    
      [ 
        { 
        "name": "Утюг", 
        "number_of_sales__sum": 100 
        }, 
        { 
        "name": "Репа", 
        "number_of_sales__sum": 400 
        } 
      ]

### Расширенный OPTIONS-запрос

OPTIONS-запрос предоставляет дополнительные сведения о моделе.
Информация связным моделям(поля типа ForeignKey) содержится в ключах

      "related_model_name": Имя модели в CamelCase,
      "related_model_url": URL до модели,
      "related_model_detailed": Поля связной модели

Общая информация содержится в ключах

  По ключу "extra_actions" предоставляется список доступных actions к объекту

  По ключу "content_type_id" id модели в таблице ContentType - этот id необходим для работы с типом поля GenericForeignKey 
### Автоматическая маршрутизации URL-адресов

URL генерируется путем перевода наименования модели в CamelCase в разделенные дефисом слова.
Например: модель ``ExampleTable`` будет иметь URL ``example-table``
